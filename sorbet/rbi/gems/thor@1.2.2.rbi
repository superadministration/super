# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `thor` gem.
# Please instead update this file by running `bin/tapioca gem thor`.

# source://thor//lib/thor/command.rb#1
class Thor
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  extend ::Thor::Base::ClassMethods
  extend ::Thor::Invocation::ClassMethods

  # source://thor//lib/thor.rb#505
  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  class << self
    # source://thor//lib/thor.rb#255
    def check_unknown_options!(options = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#268
    def check_unknown_options?(config); end

    # source://thor//lib/thor.rb#172
    def command_help(shell, command_name); end

    # source://thor//lib/thor.rb#21
    def default_command(meth = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#21
    def default_task(meth = T.unsafe(nil)); end

    # source://thor//lib/thor/base.rb#26
    def deprecation_warning(message); end

    # source://thor//lib/thor.rb#54
    def desc(usage, description, options = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#339
    def disable_required_check!(*command_names); end

    # source://thor//lib/thor.rb#343
    def disable_required_check?(command); end

    # source://thor//lib/thor.rb#195
    def help(shell, subcommand = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#71
    def long_desc(long_description, options = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#93
    def map(mappings = T.unsafe(nil), **kw); end

    # source://thor//lib/thor.rb#155
    def method_option(name, options = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#121
    def method_options(options = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#155
    def option(name, options = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#121
    def options(options = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#12
    def package_name(name, _ = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#214
    def printable_commands(all = T.unsafe(nil), subcommand = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#214
    def printable_tasks(all = T.unsafe(nil), subcommand = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#37
    def register(klass, subcommand_name, usage, description, options = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#325
    def stop_on_unknown_option!(*command_names); end

    # source://thor//lib/thor.rb#329
    def stop_on_unknown_option?(command); end

    # source://thor//lib/thor.rb#234
    def subcommand(subcommand, subcommand_class); end

    # source://thor//lib/thor.rb#230
    def subcommand_classes; end

    # source://thor//lib/thor.rb#225
    def subcommands; end

    # source://thor//lib/thor.rb#234
    def subtask(subcommand, subcommand_class); end

    # source://thor//lib/thor.rb#225
    def subtasks; end

    # source://thor//lib/thor.rb#172
    def task_help(shell, command_name); end

    protected

    # source://thor//lib/thor.rb#400
    def banner(command, namespace = T.unsafe(nil), subcommand = T.unsafe(nil)); end

    # source://thor//lib/thor.rb#406
    def baseclass; end

    # source://thor//lib/thor.rb#414
    def create_command(meth); end

    # source://thor//lib/thor.rb#414
    def create_task(meth); end

    # source://thor//lib/thor.rb#354
    def disable_required_check; end

    # source://thor//lib/thor.rb#359
    def dispatch(meth, given_args, given_opts, config); end

    # source://thor//lib/thor.rb#410
    def dynamic_command_class; end

    # source://thor//lib/thor.rb#476
    def find_command_possibilities(meth); end

    # source://thor//lib/thor.rb#476
    def find_task_possibilities(meth); end

    # source://thor//lib/thor.rb#436
    def initialize_added; end

    # source://thor//lib/thor.rb#455
    def normalize_command_name(meth); end

    # source://thor//lib/thor.rb#455
    def normalize_task_name(meth); end

    # source://thor//lib/thor.rb#442
    def retrieve_command_name(args); end

    # source://thor//lib/thor.rb#442
    def retrieve_task_name(args); end

    # source://thor//lib/thor.rb#349
    def stop_on_unknown_option; end

    # source://thor//lib/thor.rb#491
    def subcommand_help(cmd); end

    # source://thor//lib/thor.rb#491
    def subtask_help(cmd); end
  end
end

# source://thor//lib/thor/actions/empty_directory.rb#2
module Thor::Actions
  mixes_in_class_methods ::Thor::Actions::ClassMethods

  # source://thor//lib/thor/actions.rb#72
  def initialize(args = T.unsafe(nil), options = T.unsafe(nil), config = T.unsafe(nil)); end

  # source://thor//lib/thor/actions.rb#89
  def action(instance); end

  # source://thor//lib/thor/actions/create_file.rb#22
  def add_file(destination, *args, &block); end

  # source://thor//lib/thor/actions/create_link.rb#17
  def add_link(destination, *args); end

  # source://thor//lib/thor/actions/file_manipulation.rb#195
  def append_file(path, *args, &block); end

  # source://thor//lib/thor/actions/file_manipulation.rb#195
  def append_to_file(path, *args, &block); end

  # source://thor//lib/thor/actions.rb#216
  def apply(path, config = T.unsafe(nil)); end

  # source://thor//lib/thor/actions.rb#10
  def behavior; end

  # source://thor//lib/thor/actions.rb#10
  def behavior=(_arg0); end

  # source://thor//lib/thor/actions/file_manipulation.rb#148
  def chmod(path, mode, config = T.unsafe(nil)); end

  # source://thor//lib/thor/actions/file_manipulation.rb#312
  def comment_lines(path, flag, *args); end

  # source://thor//lib/thor/actions/file_manipulation.rb#21
  def copy_file(source, *args, &block); end

  # source://thor//lib/thor/actions/create_file.rb#22
  def create_file(destination, *args, &block); end

  # source://thor//lib/thor/actions/create_link.rb#17
  def create_link(destination, *args); end

  # source://thor//lib/thor/actions.rb#99
  def destination_root; end

  # source://thor//lib/thor/actions.rb#106
  def destination_root=(root); end

  # source://thor//lib/thor/actions/directory.rb#49
  def directory(source, *args, &block); end

  # source://thor//lib/thor/actions/empty_directory.rb#13
  def empty_directory(destination, config = T.unsafe(nil)); end

  # source://thor//lib/thor/actions.rb#133
  def find_in_source_paths(file); end

  # source://thor//lib/thor/actions/file_manipulation.rb#79
  def get(source, *args, &block); end

  # source://thor//lib/thor/actions/file_manipulation.rb#265
  def gsub_file(path, flag, *args, &block); end

  # source://thor//lib/thor/actions.rb#200
  def in_root; end

  # source://thor//lib/thor/actions/file_manipulation.rb#219
  def inject_into_class(path, klass, *args, &block); end

  # source://thor//lib/thor/actions/inject_into_file.rb#26
  def inject_into_file(destination, *args, &block); end

  # source://thor//lib/thor/actions/file_manipulation.rb#242
  def inject_into_module(path, module_name, *args, &block); end

  # source://thor//lib/thor/actions/inject_into_file.rb#26
  def insert_into_file(destination, *args, &block); end

  # source://thor//lib/thor/actions.rb#170
  def inside(dir = T.unsafe(nil), config = T.unsafe(nil), &block); end

  # source://thor//lib/thor/actions/file_manipulation.rb#51
  def link_file(source, *args); end

  # source://thor//lib/thor/actions/file_manipulation.rb#173
  def prepend_file(path, *args, &block); end

  # source://thor//lib/thor/actions/file_manipulation.rb#173
  def prepend_to_file(path, *args, &block); end

  # source://thor//lib/thor/actions.rb#114
  def relative_to_original_destination_root(path, remove_dot = T.unsafe(nil)); end

  # source://thor//lib/thor/actions/file_manipulation.rb#329
  def remove_dir(path, config = T.unsafe(nil)); end

  # source://thor//lib/thor/actions/file_manipulation.rb#329
  def remove_file(path, config = T.unsafe(nil)); end

  # source://thor//lib/thor/actions.rb#249
  def run(command, config = T.unsafe(nil)); end

  # source://thor//lib/thor/actions.rb#286
  def run_ruby_script(command, config = T.unsafe(nil)); end

  # source://thor//lib/thor/actions.rb#127
  def source_paths; end

  # source://thor//lib/thor/actions/file_manipulation.rb#115
  def template(source, *args, &block); end

  # source://thor//lib/thor/actions.rb#309
  def thor(command, *args); end

  # source://thor//lib/thor/actions/file_manipulation.rb#293
  def uncomment_lines(path, flag, *args); end

  protected

  # source://thor//lib/thor/actions.rb#330
  def _cleanup_options_and_set(options, key); end

  # source://thor//lib/thor/actions.rb#326
  def _shared_configuration; end

  private

  # source://thor//lib/thor/actions/file_manipulation.rb#350
  def capture(*args); end

  # source://thor//lib/thor/actions/file_manipulation.rb#346
  def concat(string); end

  # source://thor//lib/thor/actions/file_manipulation.rb#341
  def output_buffer; end

  # source://thor//lib/thor/actions/file_manipulation.rb#341
  def output_buffer=(_arg0); end

  # source://thor//lib/thor/actions/file_manipulation.rb#354
  def with_output_buffer(buf = T.unsafe(nil)); end

  class << self
    # source://thor//lib/thor/actions.rb#12
    def included(base); end
  end
end

# source://thor//lib/thor/actions/file_manipulation.rb#366
class Thor::Actions::CapturableERB < ::ERB
  # source://thor//lib/thor/actions/file_manipulation.rb#367
  def set_eoutvar(compiler, eoutvar = T.unsafe(nil)); end
end

# source://thor//lib/thor/actions.rb#17
module Thor::Actions::ClassMethods
  # source://thor//lib/thor/actions.rb#48
  def add_runtime_options!; end

  # source://thor//lib/thor/actions.rb#22
  def source_paths; end

  # source://thor//lib/thor/actions.rb#38
  def source_paths_for_search; end

  # source://thor//lib/thor/actions.rb#27
  def source_root(path = T.unsafe(nil)); end
end

# source://thor//lib/thor/actions/create_file.rb#32
class Thor::Actions::CreateFile < ::Thor::Actions::EmptyDirectory
  # source://thor//lib/thor/actions/create_file.rb#35
  def initialize(base, destination, data, config = T.unsafe(nil)); end

  # source://thor//lib/thor/actions/create_file.rb#33
  def data; end

  # source://thor//lib/thor/actions/create_file.rb#45
  def identical?; end

  # source://thor//lib/thor/actions/create_file.rb#59
  def invoke!; end

  # source://thor//lib/thor/actions/create_file.rb#51
  def render; end

  protected

  # source://thor//lib/thor/actions/create_file.rb#99
  def force_on_collision?; end

  # source://thor//lib/thor/actions/create_file.rb#85
  def force_or_skip_or_conflict(force, skip, &block); end

  # source://thor//lib/thor/actions/create_file.rb#72
  def on_conflict_behavior(&block); end
end

# source://thor//lib/thor/actions/create_link.rb#27
class Thor::Actions::CreateLink < ::Thor::Actions::CreateFile
  # source://thor//lib/thor/actions/create_link.rb#28
  def data; end

  # source://thor//lib/thor/actions/create_link.rb#56
  def exists?; end

  # source://thor//lib/thor/actions/create_link.rb#35
  def identical?; end

  # source://thor//lib/thor/actions/create_link.rb#40
  def invoke!; end
end

# source://thor//lib/thor/actions/directory.rb#55
class Thor::Actions::Directory < ::Thor::Actions::EmptyDirectory
  # source://thor//lib/thor/actions/directory.rb#58
  def initialize(base, source, destination = T.unsafe(nil), config = T.unsafe(nil), &block); end

  # source://thor//lib/thor/actions/directory.rb#64
  def invoke!; end

  # source://thor//lib/thor/actions/directory.rb#69
  def revoke!; end

  # source://thor//lib/thor/actions/directory.rb#56
  def source; end

  protected

  # source://thor//lib/thor/actions/directory.rb#75
  def execute!; end

  # source://thor//lib/thor/actions/directory.rb#99
  def file_level_lookup(previous_lookup); end

  # source://thor//lib/thor/actions/directory.rb#103
  def files(lookup); end
end

# source://thor//lib/thor/actions/empty_directory.rb#23
class Thor::Actions::EmptyDirectory
  # source://thor//lib/thor/actions/empty_directory.rb#34
  def initialize(base, destination, config = T.unsafe(nil)); end

  # source://thor//lib/thor/actions/empty_directory.rb#24
  def base; end

  # source://thor//lib/thor/actions/empty_directory.rb#24
  def config; end

  # source://thor//lib/thor/actions/empty_directory.rb#24
  def destination; end

  # source://thor//lib/thor/actions/empty_directory.rb#45
  def exists?; end

  # source://thor//lib/thor/actions/empty_directory.rb#24
  def given_destination; end

  # source://thor//lib/thor/actions/empty_directory.rb#49
  def invoke!; end

  # source://thor//lib/thor/actions/empty_directory.rb#24
  def relative_destination; end

  # source://thor//lib/thor/actions/empty_directory.rb#56
  def revoke!; end

  protected

  # source://thor//lib/thor/actions/empty_directory.rb#103
  def convert_encoded_instructions(filename); end

  # source://thor//lib/thor/actions/empty_directory.rb#85
  def destination=(destination); end

  # source://thor//lib/thor/actions/empty_directory.rb#113
  def invoke_with_conflict_check(&block); end

  # source://thor//lib/thor/actions/empty_directory.rb#132
  def on_conflict_behavior; end

  # source://thor//lib/thor/actions/empty_directory.rb#126
  def on_file_clash_behavior; end

  # source://thor//lib/thor/actions/empty_directory.rb#67
  def pretend?; end

  # source://thor//lib/thor/actions/empty_directory.rb#138
  def say_status(status, color); end
end

# source://thor//lib/thor/actions/inject_into_file.rb#36
class Thor::Actions::InjectIntoFile < ::Thor::Actions::EmptyDirectory
  # source://thor//lib/thor/actions/inject_into_file.rb#39
  def initialize(base, destination, data, config); end

  # source://thor//lib/thor/actions/inject_into_file.rb#37
  def behavior; end

  # source://thor//lib/thor/actions/inject_into_file.rb#37
  def flag; end

  # source://thor//lib/thor/actions/inject_into_file.rb#52
  def invoke!; end

  # source://thor//lib/thor/actions/inject_into_file.rb#37
  def replacement; end

  # source://thor//lib/thor/actions/inject_into_file.rb#72
  def revoke!; end

  protected

  # source://thor//lib/thor/actions/inject_into_file.rb#108
  def replace!(regexp, string, force); end

  # source://thor//lib/thor/actions/inject_into_file.rb#88
  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

# source://thor//lib/thor/actions/inject_into_file.rb#24
Thor::Actions::WARNINGS = T.let(T.unsafe(nil), Hash)

# source://thor//lib/thor/error.rb#68
class Thor::AmbiguousCommandError < ::Thor::Error; end

# source://thor//lib/thor/error.rb#70
Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

# source://thor//lib/thor/parser/argument.rb#2
class Thor::Argument
  # source://thor//lib/thor/parser/argument.rb#8
  def initialize(name, options = T.unsafe(nil)); end

  # source://thor//lib/thor/parser/argument.rb#5
  def banner; end

  # source://thor//lib/thor/parser/argument.rb#5
  def default; end

  # source://thor//lib/thor/parser/argument.rb#5
  def description; end

  # source://thor//lib/thor/parser/argument.rb#5
  def enum; end

  # source://thor//lib/thor/parser/argument.rb#5
  def human_name; end

  # source://thor//lib/thor/parser/argument.rb#5
  def name; end

  # source://thor//lib/thor/parser/argument.rb#5
  def required; end

  # source://thor//lib/thor/parser/argument.rb#31
  def required?; end

  # source://thor//lib/thor/parser/argument.rb#35
  def show_default?; end

  # source://thor//lib/thor/parser/argument.rb#5
  def type; end

  # source://thor//lib/thor/parser/argument.rb#27
  def usage; end

  protected

  # source://thor//lib/thor/parser/argument.rb#55
  def default_banner; end

  # source://thor//lib/thor/parser/argument.rb#51
  def valid_type?(type); end

  # source://thor//lib/thor/parser/argument.rb#46
  def validate!; end
end

# source://thor//lib/thor/parser/argument.rb#3
Thor::Argument::VALID_TYPES = T.let(T.unsafe(nil), Array)

# source://thor//lib/thor/parser/arguments.rb#2
class Thor::Arguments
  # source://thor//lib/thor/parser/arguments.rb#26
  def initialize(arguments = T.unsafe(nil)); end

  # source://thor//lib/thor/parser/arguments.rb#44
  def parse(args); end

  # source://thor//lib/thor/parser/arguments.rb#57
  def remaining; end

  private

  # source://thor//lib/thor/parser/arguments.rb#170
  def check_requirement!; end

  # source://thor//lib/thor/parser/arguments.rb#88
  def current_is_value?; end

  # source://thor//lib/thor/parser/arguments.rb#68
  def last?; end

  # source://thor//lib/thor/parser/arguments.rb#63
  def no_or_skip?(arg); end

  # source://thor//lib/thor/parser/arguments.rb#122
  def parse_array(name); end

  # source://thor//lib/thor/parser/arguments.rb#101
  def parse_hash(name); end

  # source://thor//lib/thor/parser/arguments.rb#133
  def parse_numeric(name); end

  # source://thor//lib/thor/parser/arguments.rb#154
  def parse_string(name); end

  # source://thor//lib/thor/parser/arguments.rb#72
  def peek; end

  # source://thor//lib/thor/parser/arguments.rb#76
  def shift; end

  # source://thor//lib/thor/parser/arguments.rb#80
  def unshift(arg); end

  class << self
    # source://thor//lib/thor/parser/arguments.rb#19
    def parse(*args); end

    # source://thor//lib/thor/parser/arguments.rb#8
    def split(args); end
  end
end

# source://thor//lib/thor/parser/arguments.rb#3
Thor::Arguments::NUMERIC = T.let(T.unsafe(nil), Regexp)

# source://thor//lib/thor/shell.rb#4
module Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell

  mixes_in_class_methods ::Thor::Base::ClassMethods
  mixes_in_class_methods ::Thor::Invocation::ClassMethods

  # source://thor//lib/thor/base.rb#53
  def initialize(args = T.unsafe(nil), local_options = T.unsafe(nil), config = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#35
  def args; end

  # source://thor//lib/thor/base.rb#35
  def args=(_arg0); end

  # source://thor//lib/thor/base.rb#35
  def options; end

  # source://thor//lib/thor/base.rb#35
  def options=(_arg0); end

  # source://thor//lib/thor/base.rb#35
  def parent_options; end

  # source://thor//lib/thor/base.rb#35
  def parent_options=(_arg0); end

  class << self
    # source://thor//lib/thor/base.rb#100
    def included(base); end

    # source://thor//lib/thor/base.rb#128
    def register_klass_file(klass); end

    # source://thor//lib/thor/shell.rb#11
    def shell; end

    # source://thor//lib/thor/shell.rb#6
    def shell=(_arg0); end

    # source://thor//lib/thor/base.rb#121
    def subclass_files; end

    # source://thor//lib/thor/base.rb#112
    def subclasses; end
  end
end

# source://thor//lib/thor/base.rb#137
module Thor::Base::ClassMethods
  # source://thor//lib/thor/base.rb#383
  def all_commands; end

  # source://thor//lib/thor/base.rb#383
  def all_tasks; end

  # source://thor//lib/thor/base.rb#173
  def allow_incompatible_default_type!; end

  # source://thor//lib/thor/base.rb#245
  def argument(name, options = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#277
  def arguments; end

  # source://thor//lib/thor/base.rb#146
  def attr_accessor(*_arg0); end

  # source://thor//lib/thor/base.rb#138
  def attr_reader(*_arg0); end

  # source://thor//lib/thor/base.rb#142
  def attr_writer(*_arg0); end

  # source://thor//lib/thor/base.rb#177
  def check_default_type; end

  # source://thor//lib/thor/base.rb#167
  def check_default_type!; end

  # source://thor//lib/thor/base.rb#156
  def check_unknown_options; end

  # source://thor//lib/thor/base.rb#152
  def check_unknown_options!; end

  # source://thor//lib/thor/base.rb#160
  def check_unknown_options?(config); end

  # source://thor//lib/thor/base.rb#312
  def class_option(name, options = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#290
  def class_options(options = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#372
  def commands; end

  # source://thor//lib/thor/base.rb#191
  def disable_required_check?(command_name); end

  # source://thor//lib/thor/base.rb#529
  def exit_on_failure?; end

  # source://thor//lib/thor/base.rb#358
  def group(name = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#519
  def handle_argument_error(command, error, args, arity); end

  # source://thor//lib/thor/base.rb#514
  def handle_no_command_error(command, has_namespace = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#514
  def handle_no_task_error(command, has_namespace = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#467
  def namespace(name = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#431
  def no_commands(&block); end

  # source://thor//lib/thor/base.rb#441
  def no_commands?; end

  # source://thor//lib/thor/base.rb#437
  def no_commands_context; end

  # source://thor//lib/thor/base.rb#431
  def no_tasks(&block); end

  # source://thor//lib/thor/base.rb#507
  def public_command(*names); end

  # source://thor//lib/thor/base.rb#507
  def public_task(*names); end

  # source://thor//lib/thor/base.rb#327
  def remove_argument(*names); end

  # source://thor//lib/thor/base.rb#346
  def remove_class_option(*names); end

  # source://thor//lib/thor/base.rb#401
  def remove_command(*names); end

  # source://thor//lib/thor/base.rb#401
  def remove_task(*names); end

  # source://thor//lib/thor/base.rb#483
  def start(given_args = T.unsafe(nil), config = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#185
  def stop_on_unknown_option?(command_name); end

  # source://thor//lib/thor/base.rb#202
  def strict_args_position; end

  # source://thor//lib/thor/base.rb#198
  def strict_args_position!; end

  # source://thor//lib/thor/base.rb#206
  def strict_args_position?(config); end

  # source://thor//lib/thor/base.rb#372
  def tasks; end

  protected

  # source://thor//lib/thor/base.rb#678
  def baseclass; end

  # source://thor//lib/thor/base.rb#672
  def basename; end

  # source://thor//lib/thor/base.rb#589
  def build_option(name, options, scope); end

  # source://thor//lib/thor/base.rb#600
  def build_options(options, scope); end

  # source://thor//lib/thor/base.rb#539
  def class_options_help(shell, groups = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#683
  def create_command(meth); end

  # source://thor//lib/thor/base.rb#683
  def create_task(meth); end

  # source://thor//lib/thor/base.rb#693
  def dispatch(command, given_args, given_opts, config); end

  # source://thor//lib/thor/base.rb#609
  def find_and_refresh_command(name); end

  # source://thor//lib/thor/base.rb#609
  def find_and_refresh_task(name); end

  # source://thor//lib/thor/base.rb#650
  def from_superclass(method, default = T.unsafe(nil)); end

  # source://thor//lib/thor/base.rb#622
  def inherited(klass); end

  # source://thor//lib/thor/base.rb#689
  def initialize_added; end

  # source://thor//lib/thor/base.rb#578
  def is_thor_reserved_word?(word, type); end

  # source://thor//lib/thor/base.rb#630
  def method_added(meth); end

  # source://thor//lib/thor/base.rb#557
  def print_options(shell, options, group_name = T.unsafe(nil)); end
end

# source://thor//lib/thor/command.rb#2
class Thor::Command < ::Struct
  # source://thor//lib/thor/command.rb#5
  def initialize(name, description, long_description, usage, options = T.unsafe(nil)); end

  # source://thor//lib/thor/command.rb#41
  def formatted_usage(klass, namespace = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://thor//lib/thor/command.rb#14
  def hidden?; end

  # source://thor//lib/thor/command.rb#20
  def run(instance, args = T.unsafe(nil)); end

  protected

  # source://thor//lib/thor/command.rb#105
  def handle_argument_error?(instance, error, caller); end

  # source://thor//lib/thor/command.rb#112
  def handle_no_method_error?(instance, error, caller); end

  # source://thor//lib/thor/command.rb#95
  def local_method?(instance, name); end

  # source://thor//lib/thor/command.rb#78
  def not_debugging?(instance); end

  # source://thor//lib/thor/command.rb#91
  def private_method?(instance); end

  # source://thor//lib/thor/command.rb#87
  def public_method?(instance); end

  # source://thor//lib/thor/command.rb#68
  def required_arguments_for(klass, usage); end

  # source://thor//lib/thor/command.rb#82
  def required_options; end

  # source://thor//lib/thor/command.rb#100
  def sans_backtrace(backtrace, caller); end

  private

  # source://thor//lib/thor/command.rb#9
  def initialize_copy(other); end
end

# source://thor//lib/thor/command.rb#3
Thor::Command::FILE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#2
module Thor::CoreExt; end

# source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#11
class Thor::CoreExt::HashWithIndifferentAccess < ::Hash
  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#12
  def initialize(hash = T.unsafe(nil)); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#19
  def [](key); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#23
  def []=(key, value); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#27
  def delete(key); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#31
  def except(*keys); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#37
  def fetch(key, *args); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#41
  def key?(key); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#49
  def merge(other); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#53
  def merge!(other); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#68
  def replace(other_hash); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#60
  def reverse_merge(other); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#64
  def reverse_merge!(other_hash); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#73
  def to_hash; end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#45
  def values_at(*indices); end

  protected

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#79
  def convert_key(key); end

  # source://thor//lib/thor/core_ext/hash_with_indifferent_access.rb#89
  def method_missing(method, *args); end
end

# source://thor//lib/thor/error.rb#14
module Thor::Correctable
  # source://thor//lib/thor/error.rb#19
  def corrections; end

  # source://thor//lib/thor/error.rb#15
  def to_s; end
end

# source://thor//lib/thor/command.rb#128
class Thor::DynamicCommand < ::Thor::Command
  # source://thor//lib/thor/command.rb#129
  def initialize(name, options = T.unsafe(nil)); end

  # source://thor//lib/thor/command.rb#133
  def run(instance, args = T.unsafe(nil)); end
end

# source://thor//lib/thor/command.rb#141
Thor::DynamicTask = Thor::DynamicCommand

# source://thor//lib/thor/error.rb#31
class Thor::Error < ::StandardError; end

# source://thor//lib/thor/group.rb#7
class Thor::Group
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  extend ::Thor::Base::ClassMethods
  extend ::Thor::Invocation::ClassMethods

  protected

  # source://thor//lib/thor/group.rb#265
  def _invoke_for_class_method(klass, command = T.unsafe(nil), *args, &block); end

  class << self
    # source://thor//lib/thor/group.rb#161
    def class_options_help(shell, groups = T.unsafe(nil)); end

    # source://thor//lib/thor/group.rb#16
    def desc(description = T.unsafe(nil)); end

    # source://thor//lib/thor/group.rb#172
    def get_options_from_invocations(group_options, base_options); end

    # source://thor//lib/thor/group.rb#207
    def handle_argument_error(command, error, _args, arity); end

    # source://thor//lib/thor/group.rb#29
    def help(shell); end

    # source://thor//lib/thor/group.rb#45
    def invocation_blocks; end

    # source://thor//lib/thor/group.rb#39
    def invocations; end

    # source://thor//lib/thor/group.rb#56
    def invoke(*names, &block); end

    # source://thor//lib/thor/group.rb#110
    def invoke_from_option(*names, &block); end

    # source://thor//lib/thor/group.rb#199
    def printable_commands(*_arg0); end

    # source://thor//lib/thor/group.rb#199
    def printable_tasks(*_arg0); end

    # source://thor//lib/thor/group.rb#149
    def remove_invocation(*names); end

    protected

    # source://thor//lib/thor/group.rb#238
    def banner; end

    # source://thor//lib/thor/group.rb#248
    def baseclass; end

    # source://thor//lib/thor/group.rb#252
    def create_command(meth); end

    # source://thor//lib/thor/group.rb#252
    def create_task(meth); end

    # source://thor//lib/thor/group.rb#217
    def dispatch(command, given_args, given_opts, config); end

    # source://thor//lib/thor/group.rb#243
    def self_command; end

    # source://thor//lib/thor/group.rb#243
    def self_task; end
  end
end

# source://thor//lib/thor/base.rb#17
Thor::HELP_MAPPINGS = T.let(T.unsafe(nil), Array)

# source://thor//lib/thor/command.rb#120
class Thor::HiddenCommand < ::Thor::Command
  # source://thor//lib/thor/command.rb#121
  def hidden?; end
end

# source://thor//lib/thor/command.rb#125
Thor::HiddenTask = Thor::HiddenCommand

# source://thor//lib/thor/invocation.rb#2
module Thor::Invocation
  mixes_in_class_methods ::Thor::Invocation::ClassMethods

  # source://thor//lib/thor/invocation.rb#23
  def initialize(args = T.unsafe(nil), options = T.unsafe(nil), config = T.unsafe(nil), &block); end

  # source://thor//lib/thor/invocation.rb#30
  def current_command_chain; end

  # source://thor//lib/thor/invocation.rb#102
  def invoke(name = T.unsafe(nil), *args); end

  # source://thor//lib/thor/invocation.rb#133
  def invoke_all; end

  # source://thor//lib/thor/invocation.rb#122
  def invoke_command(command, *args); end

  # source://thor//lib/thor/invocation.rb#122
  def invoke_task(command, *args); end

  # source://thor//lib/thor/invocation.rb#138
  def invoke_with_padding(*args); end

  protected

  # source://thor//lib/thor/invocation.rb#166
  def _parse_initialization_options(args, opts, config); end

  # source://thor//lib/thor/invocation.rb#153
  def _retrieve_class_and_command(name, sent_command = T.unsafe(nil)); end

  # source://thor//lib/thor/invocation.rb#153
  def _retrieve_class_and_task(name, sent_command = T.unsafe(nil)); end

  # source://thor//lib/thor/invocation.rb#145
  def _shared_configuration; end

  class << self
    # source://thor//lib/thor/invocation.rb#3
    def included(base); end
  end
end

# source://thor//lib/thor/invocation.rb#8
module Thor::Invocation::ClassMethods
  # source://thor//lib/thor/invocation.rb#12
  def prepare_for_invocation(key, name); end
end

# source://thor//lib/thor/error.rb#73
class Thor::InvocationError < ::Thor::Error; end

# source://thor//lib/thor/line_editor/basic.rb#2
module Thor::LineEditor
  class << self
    # source://thor//lib/thor/line_editor.rb#10
    def best_available; end

    # source://thor//lib/thor/line_editor.rb#6
    def readline(prompt, options = T.unsafe(nil)); end
  end
end

# source://thor//lib/thor/line_editor/basic.rb#3
class Thor::LineEditor::Basic
  # source://thor//lib/thor/line_editor/basic.rb#10
  def initialize(prompt, options); end

  # source://thor//lib/thor/line_editor/basic.rb#4
  def options; end

  # source://thor//lib/thor/line_editor/basic.rb#4
  def prompt; end

  # source://thor//lib/thor/line_editor/basic.rb#15
  def readline; end

  private

  # source://thor//lib/thor/line_editor/basic.rb#32
  def echo?; end

  # source://thor//lib/thor/line_editor/basic.rb#22
  def get_input; end

  class << self
    # source://thor//lib/thor/line_editor/basic.rb#6
    def available?; end
  end
end

# source://thor//lib/thor/line_editor/readline.rb#3
class Thor::LineEditor::Readline < ::Thor::LineEditor::Basic
  # source://thor//lib/thor/line_editor/readline.rb#13
  def readline; end

  private

  # source://thor//lib/thor/line_editor/readline.rb#28
  def add_to_history?; end

  # source://thor//lib/thor/line_editor/readline.rb#42
  def completion_options; end

  # source://thor//lib/thor/line_editor/readline.rb#32
  def completion_proc; end

  # source://thor//lib/thor/line_editor/readline.rb#46
  def use_path_completion?; end

  class << self
    # source://thor//lib/thor/line_editor/readline.rb#4
    def available?; end
  end
end

# source://thor//lib/thor/line_editor/readline.rb#50
class Thor::LineEditor::Readline::PathCompletion
  # source://thor//lib/thor/line_editor/readline.rb#54
  def initialize(text); end

  # source://thor//lib/thor/line_editor/readline.rb#58
  def matches; end

  private

  # source://thor//lib/thor/line_editor/readline.rb#68
  def absolute_matches; end

  # source://thor//lib/thor/line_editor/readline.rb#82
  def base_path; end

  # source://thor//lib/thor/line_editor/readline.rb#78
  def glob_pattern; end

  # source://thor//lib/thor/line_editor/readline.rb#64
  def relative_matches; end

  # source://thor//lib/thor/line_editor/readline.rb#51
  def text; end
end

# source://thor//lib/thor/error.rb#109
class Thor::MalformattedArgumentError < ::Thor::InvocationError; end

# source://thor//lib/thor/nested_context.rb#2
class Thor::NestedContext
  # source://thor//lib/thor/nested_context.rb#3
  def initialize; end

  # source://thor//lib/thor/nested_context.rb#7
  def enter; end

  # source://thor//lib/thor/nested_context.rb#15
  def entered?; end

  private

  # source://thor//lib/thor/nested_context.rb#25
  def pop; end

  # source://thor//lib/thor/nested_context.rb#21
  def push; end
end

# source://thor//lib/thor/error.rb#8
class Thor::NoKwargSpellChecker < ::DidYouMean::SpellChecker
  # source://thor//lib/thor/error.rb#9
  def initialize(dictionary); end
end

# source://thor//lib/thor/parser/option.rb#2
class Thor::Option < ::Thor::Argument
  # source://thor//lib/thor/parser/option.rb#7
  def initialize(name, options = T.unsafe(nil)); end

  # source://thor//lib/thor/parser/option.rb#3
  def aliases; end

  # source://thor//lib/thor/parser/option.rb#99
  def aliases_for_usage; end

  # source://thor//lib/thor/parser/option.rb#109
  def array?; end

  # source://thor//lib/thor/parser/option.rb#109
  def boolean?; end

  # source://thor//lib/thor/parser/option.rb#3
  def group; end

  # source://thor//lib/thor/parser/option.rb#109
  def hash?; end

  # source://thor//lib/thor/parser/option.rb#3
  def hide; end

  # source://thor//lib/thor/parser/option.rb#79
  def human_name; end

  # source://thor//lib/thor/parser/option.rb#3
  def lazy_default; end

  # source://thor//lib/thor/parser/option.rb#109
  def numeric?; end

  # source://thor//lib/thor/parser/option.rb#3
  def repeatable; end

  # source://thor//lib/thor/parser/option.rb#109
  def string?; end

  # source://thor//lib/thor/parser/option.rb#75
  def switch_name; end

  # source://thor//lib/thor/parser/option.rb#83
  def usage(padding = T.unsafe(nil)); end

  protected

  # source://thor//lib/thor/parser/option.rb#159
  def dasherize(str); end

  # source://thor//lib/thor/parser/option.rb#151
  def dasherized?; end

  # source://thor//lib/thor/parser/option.rb#155
  def undasherize(str); end

  # source://thor//lib/thor/parser/option.rb#117
  def validate!; end

  # source://thor//lib/thor/parser/option.rb#122
  def validate_default_type!; end

  class << self
    # source://thor//lib/thor/parser/option.rb#45
    def parse(key, value); end
  end
end

# source://thor//lib/thor/parser/option.rb#5
Thor::Option::VALID_TYPES = T.let(T.unsafe(nil), Array)

# source://thor//lib/thor/parser/options.rb#2
class Thor::Options < ::Thor::Arguments
  # source://thor//lib/thor/parser/options.rb#32
  def initialize(hash_options = T.unsafe(nil), defaults = T.unsafe(nil), stop_on_unknown = T.unsafe(nil), disable_required_check = T.unsafe(nil)); end

  # source://thor//lib/thor/parser/options.rb#141
  def check_unknown!; end

  # source://thor//lib/thor/parser/options.rb#88
  def parse(args); end

  # source://thor//lib/thor/parser/options.rb#64
  def peek; end

  # source://thor//lib/thor/parser/options.rb#60
  def remaining; end

  # source://thor//lib/thor/parser/options.rb#78
  def shift; end

  # source://thor//lib/thor/parser/options.rb#83
  def unshift(arg, is_value: T.unsafe(nil)); end

  protected

  # source://thor//lib/thor/parser/options.rb#151
  def assign_result!(option, result); end

  # source://thor//lib/thor/parser/options.rb#165
  def current_is_switch?; end

  # source://thor//lib/thor/parser/options.rb#177
  def current_is_switch_formatted?; end

  # source://thor//lib/thor/parser/options.rb#187
  def current_is_value?; end

  # source://thor//lib/thor/parser/options.rb#206
  def normalize_switch(arg); end

  # source://thor//lib/thor/parser/options.rb#217
  def parse_boolean(switch); end

  # source://thor//lib/thor/parser/options.rb#235
  def parse_peek(switch, option); end

  # source://thor//lib/thor/parser/options.rb#210
  def parsing_options?; end

  # source://thor//lib/thor/parser/options.rb#192
  def switch?(arg); end

  # source://thor//lib/thor/parser/options.rb#196
  def switch_option(arg); end

  class << self
    # source://thor//lib/thor/parser/options.rb#11
    def to_switches(options); end
  end
end

# source://thor//lib/thor/parser/options.rb#5
Thor::Options::EQ_RE = T.let(T.unsafe(nil), Regexp)

# source://thor//lib/thor/parser/options.rb#3
Thor::Options::LONG_RE = T.let(T.unsafe(nil), Regexp)

# source://thor//lib/thor/parser/options.rb#8
Thor::Options::OPTS_END = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/parser/options.rb#7
Thor::Options::SHORT_NUM = T.let(T.unsafe(nil), Regexp)

# source://thor//lib/thor/parser/options.rb#4
Thor::Options::SHORT_RE = T.let(T.unsafe(nil), Regexp)

# source://thor//lib/thor/parser/options.rb#6
Thor::Options::SHORT_SQ_RE = T.let(T.unsafe(nil), Regexp)

# source://thor//lib/thor/rake_compat.rb#20
module Thor::RakeCompat
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::Rake::FileUtilsExt
  include ::Rake::DSL

  class << self
    # source://thor//lib/thor/rake_compat.rb#27
    def included(base); end

    # source://thor//lib/thor/rake_compat.rb#23
    def rake_classes; end
  end
end

# source://thor//lib/thor/error.rb#106
class Thor::RequiredArgumentMissingError < ::Thor::InvocationError; end

# source://thor//lib/thor/util.rb#4
module Thor::Sandbox; end

# source://thor//lib/thor/shell.rb#23
module Thor::Shell
  # source://thor//lib/thor/shell.rb#44
  def initialize(args = T.unsafe(nil), options = T.unsafe(nil), config = T.unsafe(nil)); end

  # source://thor//lib/thor/shell.rb#59
  def ask(*args, &block); end

  # source://thor//lib/thor/shell.rb#59
  def error(*args, &block); end

  # source://thor//lib/thor/shell.rb#59
  def file_collision(*args, &block); end

  # source://thor//lib/thor/shell.rb#59
  def no?(*args, &block); end

  # source://thor//lib/thor/shell.rb#59
  def print_in_columns(*args, &block); end

  # source://thor//lib/thor/shell.rb#59
  def print_table(*args, &block); end

  # source://thor//lib/thor/shell.rb#59
  def print_wrapped(*args, &block); end

  # source://thor//lib/thor/shell.rb#59
  def say(*args, &block); end

  # source://thor//lib/thor/shell.rb#59
  def say_error(*args, &block); end

  # source://thor//lib/thor/shell.rb#59
  def say_status(*args, &block); end

  # source://thor//lib/thor/shell.rb#59
  def set_color(*args, &block); end

  # source://thor//lib/thor/shell.rb#52
  def shell; end

  # source://thor//lib/thor/shell.rb#25
  def shell=(_arg0); end

  # source://thor//lib/thor/shell.rb#59
  def terminal_width(*args, &block); end

  # source://thor//lib/thor/shell.rb#66
  def with_padding; end

  # source://thor//lib/thor/shell.rb#59
  def yes?(*args, &block); end

  protected

  # source://thor//lib/thor/shell.rb#77
  def _shared_configuration; end
end

# source://thor//lib/thor/shell/basic.rb#3
class Thor::Shell::Basic
  # source://thor//lib/thor/shell/basic.rb#11
  def initialize; end

  # source://thor//lib/thor/shell/basic.rb#78
  def ask(statement, *args); end

  # source://thor//lib/thor/shell/basic.rb#6
  def base; end

  # source://thor//lib/thor/shell/basic.rb#6
  def base=(_arg0); end

  # source://thor//lib/thor/shell/basic.rb#342
  def error(statement); end

  # source://thor//lib/thor/shell/basic.rb#285
  def file_collision(destination); end

  # source://thor//lib/thor/shell/basic.rb#41
  def indent(count = T.unsafe(nil)); end

  # source://thor//lib/thor/shell/basic.rb#20
  def mute; end

  # source://thor//lib/thor/shell/basic.rb#29
  def mute?; end

  # source://thor//lib/thor/shell/basic.rb#154
  def no?(statement, color = T.unsafe(nil)); end

  # source://thor//lib/thor/shell/basic.rb#7
  def padding; end

  # source://thor//lib/thor/shell/basic.rb#35
  def padding=(value); end

  # source://thor//lib/thor/shell/basic.rb#163
  def print_in_columns(array); end

  # source://thor//lib/thor/shell/basic.rb#185
  def print_table(array, options = T.unsafe(nil)); end

  # source://thor//lib/thor/shell/basic.rb#247
  def print_wrapped(message, options = T.unsafe(nil)); end

  # source://thor//lib/thor/shell/basic.rb#96
  def say(message = T.unsafe(nil), color = T.unsafe(nil), force_new_line = T.unsafe(nil)); end

  # source://thor//lib/thor/shell/basic.rb#113
  def say_error(message = T.unsafe(nil), color = T.unsafe(nil), force_new_line = T.unsafe(nil)); end

  # source://thor//lib/thor/shell/basic.rb#128
  def say_status(status, message, log_status = T.unsafe(nil)); end

  # source://thor//lib/thor/shell/basic.rb#349
  def set_color(string, *_arg1); end

  # source://thor//lib/thor/shell/basic.rb#326
  def terminal_width; end

  # source://thor//lib/thor/shell/basic.rb#147
  def yes?(statement, color = T.unsafe(nil)); end

  protected

  # source://thor//lib/thor/shell/basic.rb#486
  def answer_match(possibilities, answer, case_insensitive); end

  # source://thor//lib/thor/shell/basic.rb#443
  def as_unicode; end

  # source://thor//lib/thor/shell/basic.rb#473
  def ask_filtered(statement, color, options); end

  # source://thor//lib/thor/shell/basic.rb#456
  def ask_simply(statement, color, options); end

  # source://thor//lib/thor/shell/basic.rb#360
  def can_display_colors?; end

  # source://thor//lib/thor/shell/basic.rb#415
  def dynamic_width; end

  # source://thor//lib/thor/shell/basic.rb#419
  def dynamic_width_stty; end

  # source://thor//lib/thor/shell/basic.rb#423
  def dynamic_width_tput; end

  # source://thor//lib/thor/shell/basic.rb#387
  def file_collision_help; end

  # source://thor//lib/thor/shell/basic.rb#507
  def git_merge_tool; end

  # source://thor//lib/thor/shell/basic.rb#377
  def is?(value); end

  # source://thor//lib/thor/shell/basic.rb#364
  def lookup_color(color); end

  # source://thor//lib/thor/shell/basic.rb#494
  def merge(destination, content); end

  # source://thor//lib/thor/shell/basic.rb#503
  def merge_tool; end

  # source://thor//lib/thor/shell/basic.rb#355
  def prepare_message(message, *color); end

  # source://thor//lib/thor/shell/basic.rb#410
  def quiet?; end

  # source://thor//lib/thor/shell/basic.rb#399
  def show_diff(destination, content); end

  # source://thor//lib/thor/shell/basic.rb#373
  def stderr; end

  # source://thor//lib/thor/shell/basic.rb#369
  def stdout; end

  # source://thor//lib/thor/shell/basic.rb#431
  def truncate(string, width); end

  # source://thor//lib/thor/shell/basic.rb#427
  def unix?; end
end

# source://thor//lib/thor/shell/basic.rb#4
Thor::Shell::Basic::DEFAULT_TERMINAL_WIDTH = T.let(T.unsafe(nil), Integer)

# source://thor//lib/thor/shell/color.rb#9
class Thor::Shell::Color < ::Thor::Shell::Basic
  # source://thor//lib/thor/shell/color.rb#79
  def set_color(string, *colors); end

  protected

  # source://thor//lib/thor/shell/color.rb#107
  def are_colors_disabled?; end

  # source://thor//lib/thor/shell/color.rb#103
  def are_colors_supported?; end

  # source://thor//lib/thor/shell/color.rb#99
  def can_display_colors?; end

  # source://thor//lib/thor/shell/color.rb#144
  def diff_lcs_loaded?; end

  # source://thor//lib/thor/shell/color.rb#127
  def output_diff_line(diff); end

  # source://thor//lib/thor/shell/color.rb#114
  def show_diff(destination, content); end
end

# source://thor//lib/thor/shell/color.rb#15
Thor::Shell::Color::BLACK = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#23
Thor::Shell::Color::BLUE = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#12
Thor::Shell::Color::BOLD = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#10
Thor::Shell::Color::CLEAR = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#27
Thor::Shell::Color::CYAN = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#19
Thor::Shell::Color::GREEN = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#25
Thor::Shell::Color::MAGENTA = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#32
Thor::Shell::Color::ON_BLACK = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#40
Thor::Shell::Color::ON_BLUE = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#44
Thor::Shell::Color::ON_CYAN = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#36
Thor::Shell::Color::ON_GREEN = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#42
Thor::Shell::Color::ON_MAGENTA = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#34
Thor::Shell::Color::ON_RED = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#46
Thor::Shell::Color::ON_WHITE = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#38
Thor::Shell::Color::ON_YELLOW = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#17
Thor::Shell::Color::RED = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#29
Thor::Shell::Color::WHITE = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/color.rb#21
Thor::Shell::Color::YELLOW = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#9
class Thor::Shell::HTML < ::Thor::Shell::Basic
  # source://thor//lib/thor/shell/html.rb#70
  def ask(statement, color = T.unsafe(nil)); end

  # source://thor//lib/thor/shell/html.rb#51
  def set_color(string, *colors); end

  protected

  # source://thor//lib/thor/shell/html.rb#76
  def can_display_colors?; end

  # source://thor//lib/thor/shell/html.rb#113
  def diff_lcs_loaded?; end

  # source://thor//lib/thor/shell/html.rb#96
  def output_diff_line(diff); end

  # source://thor//lib/thor/shell/html.rb#83
  def show_diff(destination, content); end
end

# source://thor//lib/thor/shell/html.rb#13
Thor::Shell::HTML::BLACK = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#21
Thor::Shell::HTML::BLUE = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#10
Thor::Shell::HTML::BOLD = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#25
Thor::Shell::HTML::CYAN = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#17
Thor::Shell::HTML::GREEN = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#23
Thor::Shell::HTML::MAGENTA = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#30
Thor::Shell::HTML::ON_BLACK = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#38
Thor::Shell::HTML::ON_BLUE = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#42
Thor::Shell::HTML::ON_CYAN = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#34
Thor::Shell::HTML::ON_GREEN = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#40
Thor::Shell::HTML::ON_MAGENTA = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#32
Thor::Shell::HTML::ON_RED = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#44
Thor::Shell::HTML::ON_WHITE = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#36
Thor::Shell::HTML::ON_YELLOW = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#15
Thor::Shell::HTML::RED = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#27
Thor::Shell::HTML::WHITE = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell/html.rb#19
Thor::Shell::HTML::YELLOW = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/shell.rb#24
Thor::Shell::SHELL_DELEGATED_METHODS = T.let(T.unsafe(nil), Array)

# source://thor//lib/thor/base.rb#23
Thor::TEMPLATE_EXTNAME = T.let(T.unsafe(nil), String)

# source://thor//lib/thor/base.rb#20
Thor::THOR_RESERVED_WORDS = T.let(T.unsafe(nil), Array)

# source://thor//lib/thor/command.rb#117
Thor::Task = Thor::Command

# source://thor//lib/thor/error.rb#35
class Thor::UndefinedCommandError < ::Thor::Error
  include ::Thor::Correctable

  # source://thor//lib/thor/error.rb#54
  def initialize(command, all_commands, namespace); end

  # source://thor//lib/thor/error.rb#52
  def all_commands; end

  # source://thor//lib/thor/error.rb#52
  def command; end
end

# source://thor//lib/thor/error.rb#36
class Thor::UndefinedCommandError::SpellChecker
  # source://thor//lib/thor/error.rb#39
  def initialize(error); end

  # source://thor//lib/thor/error.rb#43
  def corrections; end

  # source://thor//lib/thor/error.rb#37
  def error; end

  # source://thor//lib/thor/error.rb#47
  def spell_checker; end
end

# source://thor//lib/thor/error.rb#66
Thor::UndefinedTaskError = Thor::UndefinedCommandError

# source://thor//lib/thor/error.rb#76
class Thor::UnknownArgumentError < ::Thor::Error
  include ::Thor::Correctable

  # source://thor//lib/thor/error.rb#96
  def initialize(switches, unknown); end

  # source://thor//lib/thor/error.rb#94
  def switches; end

  # source://thor//lib/thor/error.rb#94
  def unknown; end
end

# source://thor//lib/thor/error.rb#77
class Thor::UnknownArgumentError::SpellChecker
  # source://thor//lib/thor/error.rb#80
  def initialize(error); end

  # source://thor//lib/thor/error.rb#84
  def corrections; end

  # source://thor//lib/thor/error.rb#78
  def error; end

  # source://thor//lib/thor/error.rb#89
  def spell_checker; end
end

# source://thor//lib/thor/util.rb#17
module Thor::Util
  class << self
    # source://thor//lib/thor/util.rb#104
    def camel_case(str); end

    # source://thor//lib/thor/util.rb#263
    def escape_globs(path); end

    # source://thor//lib/thor/util.rb#279
    def escape_html(string); end

    # source://thor//lib/thor/util.rb#24
    def find_by_namespace(namespace); end

    # source://thor//lib/thor/util.rb#131
    def find_class_and_command_by_namespace(namespace, fallback = T.unsafe(nil)); end

    # source://thor//lib/thor/util.rb#131
    def find_class_and_task_by_namespace(namespace, fallback = T.unsafe(nil)); end

    # source://thor//lib/thor/util.rb#212
    def globs_for(path); end

    # source://thor//lib/thor/util.rb#152
    def load_thorfile(path, content = T.unsafe(nil), debug = T.unsafe(nil)); end

    # source://thor//lib/thor/util.rb#43
    def namespace_from_thor_class(constant); end

    # source://thor//lib/thor/util.rb#58
    def namespaces_in_content(contents, file = T.unsafe(nil)); end

    # source://thor//lib/thor/util.rb#220
    def ruby_command; end

    # source://thor//lib/thor/util.rb#90
    def snake_case(str); end

    # source://thor//lib/thor/util.rb#74
    def thor_classes_in(klass); end

    # source://thor//lib/thor/util.rb#191
    def thor_root; end

    # source://thor//lib/thor/util.rb#202
    def thor_root_glob; end

    # source://thor//lib/thor/util.rb#167
    def user_home; end
  end
end
