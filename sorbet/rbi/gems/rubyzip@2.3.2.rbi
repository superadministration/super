# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubyzip` gem.
# Please instead update this file by running `bin/tapioca gem rubyzip`.

# source://rubyzip//lib/zip/constants.rb#1
module Zip
  extend ::Zip

  # source://rubyzip//lib/zip.rb#38
  def case_insensitive_match; end

  # source://rubyzip//lib/zip.rb#38
  def case_insensitive_match=(_arg0); end

  # source://rubyzip//lib/zip.rb#38
  def continue_on_exists_proc; end

  # source://rubyzip//lib/zip.rb#38
  def continue_on_exists_proc=(_arg0); end

  # source://rubyzip//lib/zip.rb#38
  def default_compression; end

  # source://rubyzip//lib/zip.rb#38
  def default_compression=(_arg0); end

  # source://rubyzip//lib/zip.rb#38
  def force_entry_names_encoding; end

  # source://rubyzip//lib/zip.rb#38
  def force_entry_names_encoding=(_arg0); end

  # source://rubyzip//lib/zip.rb#38
  def on_exists_proc; end

  # source://rubyzip//lib/zip.rb#38
  def on_exists_proc=(_arg0); end

  # source://rubyzip//lib/zip.rb#49
  def reset!; end

  # source://rubyzip//lib/zip.rb#62
  def setup; end

  # source://rubyzip//lib/zip.rb#38
  def sort_entries; end

  # source://rubyzip//lib/zip.rb#38
  def sort_entries=(_arg0); end

  # source://rubyzip//lib/zip.rb#38
  def unicode_names; end

  # source://rubyzip//lib/zip.rb#38
  def unicode_names=(_arg0); end

  # source://rubyzip//lib/zip.rb#38
  def validate_entry_sizes; end

  # source://rubyzip//lib/zip.rb#38
  def validate_entry_sizes=(_arg0); end

  # source://rubyzip//lib/zip.rb#38
  def warn_invalid_date; end

  # source://rubyzip//lib/zip.rb#38
  def warn_invalid_date=(_arg0); end

  # source://rubyzip//lib/zip.rb#38
  def write_zip64_support; end

  # source://rubyzip//lib/zip.rb#38
  def write_zip64_support=(_arg0); end
end

# source://rubyzip//lib/zip/constants.rb#5
Zip::CDIR_ENTRY_STATIC_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#4
Zip::CENTRAL_DIRECTORY_ENTRY_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#89
Zip::COMPRESSION_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/constants.rb#87
Zip::COMPRESSION_METHOD_AES = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#76
Zip::COMPRESSION_METHOD_BZIP2 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#72
Zip::COMPRESSION_METHOD_DEFLATE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#73
Zip::COMPRESSION_METHOD_DEFLATE_64 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#80
Zip::COMPRESSION_METHOD_IBM_CMPSC = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#83
Zip::COMPRESSION_METHOD_IBM_LZ77 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#82
Zip::COMPRESSION_METHOD_IBM_TERSE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#70
Zip::COMPRESSION_METHOD_IMPLODE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#84
Zip::COMPRESSION_METHOD_JPEG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#78
Zip::COMPRESSION_METHOD_LZMA = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#74
Zip::COMPRESSION_METHOD_PKWARE_DCLI = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#86
Zip::COMPRESSION_METHOD_PPMD = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#66
Zip::COMPRESSION_METHOD_REDUCE_1 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#67
Zip::COMPRESSION_METHOD_REDUCE_2 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#68
Zip::COMPRESSION_METHOD_REDUCE_3 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#69
Zip::COMPRESSION_METHOD_REDUCE_4 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#65
Zip::COMPRESSION_METHOD_SHRINK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#64
Zip::COMPRESSION_METHOD_STORE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#85
Zip::COMPRESSION_METHOD_WAVPACK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#2
class Zip::CentralDirectory
  include ::Enumerable

  # source://rubyzip//lib/zip/central_directory.rb#18
  def initialize(entries = T.unsafe(nil), comment = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/central_directory.rb#202
  def ==(other); end

  # source://rubyzip//lib/zip/central_directory.rb#11
  def comment; end

  # source://rubyzip//lib/zip/central_directory.rb#184
  def each(&a_proc); end

  # source://rubyzip//lib/zip/central_directory.rb#14
  def entries; end

  # source://rubyzip//lib/zip/central_directory.rb#167
  def get_64_e_o_c_d(buf); end

  # source://rubyzip//lib/zip/central_directory.rb#141
  def get_e_o_c_d(buf); end

  # source://rubyzip//lib/zip/central_directory.rb#87
  def read_64_e_o_c_d(buf); end

  # source://rubyzip//lib/zip/central_directory.rb#119
  def read_central_directory_entries(io); end

  # source://rubyzip//lib/zip/central_directory.rb#102
  def read_e_o_c_d(buf); end

  # source://rubyzip//lib/zip/central_directory.rb#131
  def read_from_stream(io); end

  # source://rubyzip//lib/zip/central_directory.rb#190
  def size; end

  # source://rubyzip//lib/zip/central_directory.rb#158
  def start_buf(io); end

  # source://rubyzip//lib/zip/central_directory.rb#24
  def write_to_stream(io); end

  # source://rubyzip//lib/zip/central_directory.rb#154
  def zip64_file?(buf); end

  private

  # source://rubyzip//lib/zip/central_directory.rb#57
  def write_64_e_o_c_d(io, offset, cdir_size); end

  # source://rubyzip//lib/zip/central_directory.rb#75
  def write_64_eocd_locator(io, zip64_eocd_offset); end

  # source://rubyzip//lib/zip/central_directory.rb#40
  def write_e_o_c_d(io, offset, cdir_size); end

  class << self
    # source://rubyzip//lib/zip/central_directory.rb#194
    def read_from_stream(io); end
  end
end

# source://rubyzip//lib/zip/central_directory.rb#5
Zip::CentralDirectory::END_OF_CDS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#8
Zip::CentralDirectory::MAX_END_OF_CDS_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#9
Zip::CentralDirectory::STATIC_EOCD_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#6
Zip::CentralDirectory::ZIP64_END_OF_CDS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#7
Zip::CentralDirectory::ZIP64_EOCD_LOCATOR = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#5
class Zip::CompressionMethodError < ::Zip::Error; end

# source://rubyzip//lib/zip/compressor.rb#2
class Zip::Compressor
  # source://rubyzip//lib/zip/compressor.rb#3
  def finish; end
end

# source://rubyzip//lib/zip/dos_time.rb#3
class Zip::DOSTime < ::Time
  # source://rubyzip//lib/zip/dos_time.rb#28
  def dos_equals(other); end

  # source://rubyzip//lib/zip/dos_time.rb#21
  def to_binary_dos_date; end

  # source://rubyzip//lib/zip/dos_time.rb#15
  def to_binary_dos_time; end

  class << self
    # source://rubyzip//lib/zip/dos_time.rb#33
    def from_time(time); end

    # source://rubyzip//lib/zip/dos_time.rb#37
    def parse_binary_dos_format(bin_dos_date, bin_dos_time); end
  end
end

# source://rubyzip//lib/zip/errors.rb#10
class Zip::DecompressionError < ::Zip::Error; end

# source://rubyzip//lib/zip/decompressor.rb#2
class Zip::Decompressor
  # source://rubyzip//lib/zip/decompressor.rb#20
  def initialize(input_stream, decompressed_size = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/decompressor.rb#18
  def decompressed_size; end

  # source://rubyzip//lib/zip/decompressor.rb#17
  def input_stream; end

  class << self
    # source://rubyzip//lib/zip/decompressor.rb#5
    def decompressor_classes; end

    # source://rubyzip//lib/zip/decompressor.rb#13
    def find_by_compression_method(compression_method); end

    # source://rubyzip//lib/zip/decompressor.rb#9
    def register(compression_method, decompressor_class); end
  end
end

# source://rubyzip//lib/zip/decompressor.rb#3
Zip::Decompressor::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/decrypted_io.rb#2
class Zip::DecryptedIo
  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#5
  def initialize(io, decrypter); end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#10
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#28
  def buffer; end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#24
  def eof; end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#32
  def input_finished?; end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#36
  def produce_input; end
end

# source://rubyzip//lib/zip/crypto/decrypted_io.rb#3
Zip::DecryptedIo::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/encryption.rb#5
class Zip::Decrypter; end

# source://rubyzip//lib/zip/deflater.rb#2
class Zip::Deflater < ::Zip::Compressor
  # source://rubyzip//lib/zip/deflater.rb#3
  def initialize(output_stream, level = T.unsafe(nil), encrypter = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/deflater.rb#12
  def <<(data); end

  # source://rubyzip//lib/zip/deflater.rb#28
  def crc; end

  # source://rubyzip//lib/zip/deflater.rb#24
  def finish; end

  # source://rubyzip//lib/zip/deflater.rb#28
  def size; end
end

# source://rubyzip//lib/zip/errors.rb#4
class Zip::DestinationFileExistsError < ::Zip::Error; end

# source://rubyzip//lib/zip/crypto/encryption.rb#2
class Zip::Encrypter; end

# source://rubyzip//lib/zip/entry.rb#3
class Zip::Entry
  # source://rubyzip//lib/zip/entry.rb#55
  def initialize(*args); end

  # source://rubyzip//lib/zip/entry.rb#512
  def <=>(other); end

  # source://rubyzip//lib/zip/entry.rb#502
  def ==(other); end

  # source://rubyzip//lib/zip/entry.rb#151
  def calculate_local_header_size; end

  # source://rubyzip//lib/zip/entry.rb#164
  def cdir_header_size; end

  # source://rubyzip//lib/zip/entry.rb#376
  def check_c_dir_entry_comment_size; end

  # source://rubyzip//lib/zip/entry.rb#370
  def check_c_dir_entry_signature; end

  # source://rubyzip//lib/zip/entry.rb#364
  def check_c_dir_entry_static_header_length(buf); end

  # source://rubyzip//lib/zip/entry.rb#49
  def check_name(name); end

  # source://rubyzip//lib/zip/entry.rb#603
  def clean_up; end

  # source://rubyzip//lib/zip/entry.rb#9
  def comment; end

  # source://rubyzip//lib/zip/entry.rb#9
  def comment=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#147
  def comment_size; end

  # source://rubyzip//lib/zip/entry.rb#9
  def compressed_size; end

  # source://rubyzip//lib/zip/entry.rb#9
  def compressed_size=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#9
  def compression_method; end

  # source://rubyzip//lib/zip/entry.rb#9
  def compression_method=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#9
  def crc; end

  # source://rubyzip//lib/zip/entry.rb#9
  def crc=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#114
  def directory?; end

  # source://rubyzip//lib/zip/entry.rb#9
  def dirty; end

  # source://rubyzip//lib/zip/entry.rb#9
  def dirty=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#76
  def encrypted?; end

  # source://rubyzip//lib/zip/entry.rb#9
  def external_file_attributes; end

  # source://rubyzip//lib/zip/entry.rb#9
  def external_file_attributes=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#9
  def extra; end

  # source://rubyzip//lib/zip/entry.rb#9
  def extra=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#143
  def extra_size; end

  # source://rubyzip//lib/zip/entry.rb#176
  def extract(dest_path = T.unsafe(nil), &block); end

  # source://rubyzip//lib/zip/entry.rb#114
  def file?; end

  # source://rubyzip//lib/zip/entry.rb#407
  def file_stat(path); end

  # source://rubyzip//lib/zip/entry.rb#106
  def file_type_is?(type); end

  # source://rubyzip//lib/zip/entry.rb#16
  def filepath; end

  # source://rubyzip//lib/zip/entry.rb#9
  def follow_symlinks; end

  # source://rubyzip//lib/zip/entry.rb#9
  def follow_symlinks=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#9
  def fstype; end

  # source://rubyzip//lib/zip/entry.rb#9
  def fstype=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#16
  def ftype; end

  # source://rubyzip//lib/zip/entry.rb#550
  def gather_fileinfo_from_srcpath(src_path); end

  # source://rubyzip//lib/zip/entry.rb#415
  def get_extra_attributes_from_path(path); end

  # source://rubyzip//lib/zip/entry.rb#518
  def get_input_stream(&block); end

  # source://rubyzip//lib/zip/entry.rb#595
  def get_raw_input_stream(&block); end

  # source://rubyzip//lib/zip/entry.rb#9
  def gp_flags; end

  # source://rubyzip//lib/zip/entry.rb#9
  def gp_flags=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#9
  def header_signature; end

  # source://rubyzip//lib/zip/entry.rb#9
  def header_signature=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#80
  def incomplete?; end

  # source://rubyzip//lib/zip/entry.rb#9
  def internal_file_attributes; end

  # source://rubyzip//lib/zip/entry.rb#9
  def internal_file_attributes=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#135
  def local_entry_offset; end

  # source://rubyzip//lib/zip/entry.rb#9
  def local_header_offset; end

  # source://rubyzip//lib/zip/entry.rb#9
  def local_header_offset=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#84
  def mtime; end

  # source://rubyzip//lib/zip/entry.rb#9
  def name; end

  # source://rubyzip//lib/zip/entry.rb#9
  def name=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#119
  def name_is_directory?; end

  # source://rubyzip//lib/zip/entry.rb#126
  def name_safe?; end

  # source://rubyzip//lib/zip/entry.rb#139
  def name_size; end

  # source://rubyzip//lib/zip/entry.rb#169
  def next_header_offset; end

  # source://rubyzip//lib/zip/entry.rb#447
  def pack_c_dir_entry; end

  # source://rubyzip//lib/zip/entry.rb#284
  def pack_local_entry; end

  # source://rubyzip//lib/zip/entry.rb#589
  def parent_as_string; end

  # source://rubyzip//lib/zip/entry.rb#390
  def read_c_dir_entry(io); end

  # source://rubyzip//lib/zip/entry.rb#382
  def read_c_dir_extra_field(io); end

  # source://rubyzip//lib/zip/entry.rb#245
  def read_local_entry(io); end

  # source://rubyzip//lib/zip/entry.rb#9
  def restore_ownership; end

  # source://rubyzip//lib/zip/entry.rb#9
  def restore_ownership=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#9
  def restore_permissions; end

  # source://rubyzip//lib/zip/entry.rb#9
  def restore_permissions=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#9
  def restore_times; end

  # source://rubyzip//lib/zip/entry.rb#9
  def restore_times=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#18
  def set_default_vars_values; end

  # source://rubyzip//lib/zip/entry.rb#438
  def set_extra_attributes_on_path(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#335
  def set_ftype_from_c_dir_entry; end

  # source://rubyzip//lib/zip/entry.rb#425
  def set_unix_attributes_on_path(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#9
  def size; end

  # source://rubyzip//lib/zip/entry.rb#9
  def size=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#114
  def symlink?; end

  # source://rubyzip//lib/zip/entry.rb#84
  def time; end

  # source://rubyzip//lib/zip/entry.rb#98
  def time=(value); end

  # source://rubyzip//lib/zip/entry.rb#191
  def to_s; end

  # source://rubyzip//lib/zip/entry.rb#9
  def unix_gid; end

  # source://rubyzip//lib/zip/entry.rb#9
  def unix_gid=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#9
  def unix_perms; end

  # source://rubyzip//lib/zip/entry.rb#9
  def unix_perms=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#9
  def unix_uid; end

  # source://rubyzip//lib/zip/entry.rb#9
  def unix_uid=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#311
  def unpack_c_dir_entry(buf); end

  # source://rubyzip//lib/zip/entry.rb#230
  def unpack_local_entry(buf); end

  # source://rubyzip//lib/zip/entry.rb#157
  def verify_local_header_size!; end

  # source://rubyzip//lib/zip/entry.rb#474
  def write_c_dir_entry(io); end

  # source://rubyzip//lib/zip/entry.rb#299
  def write_local_entry(io, rewrite = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#578
  def write_to_zip_output_stream(zip_output_stream); end

  # source://rubyzip//lib/zip/entry.rb#9
  def zipfile; end

  # source://rubyzip//lib/zip/entry.rb#9
  def zipfile=(_arg0); end

  private

  # source://rubyzip//lib/zip/entry.rb#642
  def create_directory(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#615
  def create_file(dest_path, _continue_on_exists_proc = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#659
  def create_symlink(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#677
  def data_descriptor_size; end

  # source://rubyzip//lib/zip/entry.rb#667
  def parse_zip64_extra(for_local_header); end

  # source://rubyzip//lib/zip/entry.rb#682
  def prep_zip64_extra(for_local_header); end

  # source://rubyzip//lib/zip/entry.rb#609
  def set_time(binary_dos_date, binary_dos_time); end

  class << self
    # source://rubyzip//lib/zip/entry.rb#208
    def read_c_dir_entry(io); end

    # source://rubyzip//lib/zip/entry.rb#221
    def read_local_entry(io); end

    # source://rubyzip//lib/zip/entry.rb#204
    def read_zip_64_long(io); end

    # source://rubyzip//lib/zip/entry.rb#200
    def read_zip_long(io); end

    # source://rubyzip//lib/zip/entry.rb#196
    def read_zip_short(io); end
  end
end

# source://rubyzip//lib/zip/entry.rb#5
Zip::Entry::DEFLATED = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/entry.rb#7
Zip::Entry::EFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/entry.rb#4
Zip::Entry::STORED = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#3
class Zip::EntryExistsError < ::Zip::Error; end

# source://rubyzip//lib/zip/errors.rb#6
class Zip::EntryNameError < ::Zip::Error; end

# source://rubyzip//lib/zip/entry_set.rb#2
class Zip::EntrySet
  include ::Enumerable

  # source://rubyzip//lib/zip/entry_set.rb#6
  def initialize(an_enumerable = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry_set.rb#20
  def <<(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#51
  def ==(other); end

  # source://rubyzip//lib/zip/entry_set.rb#32
  def delete(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#47
  def dup; end

  # source://rubyzip//lib/zip/entry_set.rb#36
  def each; end

  # source://rubyzip//lib/zip/entry_set.rb#42
  def entries; end

  # source://rubyzip//lib/zip/entry_set.rb#4
  def entry_order; end

  # source://rubyzip//lib/zip/entry_set.rb#4
  def entry_order=(_arg0); end

  # source://rubyzip//lib/zip/entry_set.rb#4
  def entry_set; end

  # source://rubyzip//lib/zip/entry_set.rb#4
  def entry_set=(_arg0); end

  # source://rubyzip//lib/zip/entry_set.rb#16
  def find_entry(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#61
  def glob(pattern, flags = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry_set.rb#12
  def include?(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#26
  def length; end

  # source://rubyzip//lib/zip/entry_set.rb#57
  def parent(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#20
  def push(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#26
  def size; end

  protected

  # source://rubyzip//lib/zip/entry_set.rb#72
  def sorted_entries; end

  private

  # source://rubyzip//lib/zip/entry_set.rb#78
  def to_key(entry); end
end

# source://rubyzip//lib/zip/errors.rb#7
class Zip::EntrySizeError < ::Zip::Error; end

# source://rubyzip//lib/zip/errors.rb#2
class Zip::Error < ::StandardError; end

# source://rubyzip//lib/zip/extra_field.rb#2
class Zip::ExtraField < ::Hash
  # source://rubyzip//lib/zip/extra_field.rb#5
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field.rb#80
  def c_dir_size; end

  # source://rubyzip//lib/zip/extra_field.rb#54
  def create(name); end

  # source://rubyzip//lib/zip/extra_field.rb#28
  def create_unknown_item; end

  # source://rubyzip//lib/zip/extra_field.rb#9
  def extra_field_type_exist(binstr, id, len, index); end

  # source://rubyzip//lib/zip/extra_field.rb#19
  def extra_field_type_unknown(binstr, len, index); end

  # source://rubyzip//lib/zip/extra_field.rb#84
  def length; end

  # source://rubyzip//lib/zip/extra_field.rb#84
  def local_size; end

  # source://rubyzip//lib/zip/extra_field.rb#37
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field.rb#64
  def ordered_values; end

  # source://rubyzip//lib/zip/extra_field.rb#84
  def size; end

  # source://rubyzip//lib/zip/extra_field.rb#76
  def to_c_dir_bin; end

  # source://rubyzip//lib/zip/extra_field.rb#70
  def to_local_bin; end

  # source://rubyzip//lib/zip/extra_field.rb#70
  def to_s; end
end

# source://rubyzip//lib/zip/extra_field/generic.rb#2
class Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/generic.rb#25
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/generic.rb#14
  def initial_parse(binstr); end

  # source://rubyzip//lib/zip/extra_field/generic.rb#39
  def to_c_dir_bin; end

  # source://rubyzip//lib/zip/extra_field/generic.rb#34
  def to_local_bin; end

  class << self
    # source://rubyzip//lib/zip/extra_field/generic.rb#9
    def name; end

    # source://rubyzip//lib/zip/extra_field/generic.rb#3
    def register_map; end
  end
end

# source://rubyzip//lib/zip/extra_field.rb#3
Zip::ExtraField::ID_MAP = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/extra_field/unix.rb#3
class Zip::ExtraField::IUnix < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/unix.rb#7
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#27
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#13
  def gid; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#13
  def gid=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#15
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#35
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#31
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#13
  def uid; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#13
  def uid=(_arg0); end
end

# source://rubyzip//lib/zip/extra_field/unix.rb#4
Zip::ExtraField::IUnix::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#4
class Zip::ExtraField::NTFS < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/ntfs.rb#11
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#38
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def atime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def atime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def ctime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def ctime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def mtime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#50
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#45
  def pack_for_local; end

  private

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#86
  def from_ntfs_time(ntfs_time); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#68
  def parse_tags(content); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#90
  def to_ntfs_time(time); end
end

# source://rubyzip//lib/zip/extra_field/ntfs.rb#5
Zip::ExtraField::NTFS::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#9
Zip::ExtraField::NTFS::SEC_TO_UNIX_EPOCH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#8
Zip::ExtraField::NTFS::WINDOWS_TICK = T.let(T.unsafe(nil), Float)

# source://rubyzip//lib/zip/extra_field/old_unix.rb#3
class Zip::ExtraField::OldUnix < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/old_unix.rb#7
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#31
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def atime; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def atime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def gid; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def gid=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def mtime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#42
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#38
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def uid; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def uid=(_arg0); end
end

# source://rubyzip//lib/zip/extra_field/old_unix.rb#4
Zip::ExtraField::OldUnix::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#3
class Zip::ExtraField::UniversalTime < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/universal_time.rb#11
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#57
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#20
  def atime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#22
  def atime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#20
  def ctime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#27
  def ctime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#20
  def flag; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#37
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#20
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#32
  def mtime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#71
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#63
  def pack_for_local; end
end

# source://rubyzip//lib/zip/extra_field/universal_time.rb#7
Zip::ExtraField::UniversalTime::ATIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#8
Zip::ExtraField::UniversalTime::CTIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#4
Zip::ExtraField::UniversalTime::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#9
Zip::ExtraField::UniversalTime::MTIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/zip64.rb#3
class Zip::ExtraField::Zip64 < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/zip64.rb#8
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#20
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def compressed_size; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def compressed_size=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def disk_start_number; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def disk_start_number=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#27
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def original_size; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def original_size=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#60
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#53
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#36
  def parse(original_size, compressed_size, relative_header_offset = T.unsafe(nil), disk_start_number = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def relative_header_offset; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def relative_header_offset=(_arg0); end

  private

  # source://rubyzip//lib/zip/extra_field/zip64.rb#48
  def extract(size, format); end
end

# source://rubyzip//lib/zip/extra_field/zip64.rb#5
Zip::ExtraField::Zip64::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/zip64_placeholder.rb#5
class Zip::ExtraField::Zip64Placeholder < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/zip64_placeholder.rb#9
  def initialize(_binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/zip64_placeholder.rb#11
  def pack_for_local; end
end

# source://rubyzip//lib/zip/extra_field/zip64_placeholder.rb#6
Zip::ExtraField::Zip64Placeholder::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/constants.rb#15
Zip::FILE_TYPE_DIR = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#14
Zip::FILE_TYPE_FILE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#16
Zip::FILE_TYPE_SYMLINK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#40
Zip::FSTYPES = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/constants.rb#31
Zip::FSTYPE_ACORN = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#19
Zip::FSTYPE_AMIGA = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#23
Zip::FSTYPE_ATARI = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#38
Zip::FSTYPE_ATHEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#34
Zip::FSTYPE_BEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#27
Zip::FSTYPE_CPM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#18
Zip::FSTYPE_FAT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#24
Zip::FSTYPE_HPFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#25
Zip::FSTYPE_MAC = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#37
Zip::FSTYPE_MAC_OSX = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#33
Zip::FSTYPE_MVS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#29
Zip::FSTYPE_NTFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#30
Zip::FSTYPE_QDOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#35
Zip::FSTYPE_TANDEM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#36
Zip::FSTYPE_THEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#28
Zip::FSTYPE_TOPS20 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#21
Zip::FSTYPE_UNIX = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#32
Zip::FSTYPE_VFAT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#20
Zip::FSTYPE_VMS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#22
Zip::FSTYPE_VM_CMS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#26
Zip::FSTYPE_Z_SYSTEM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#45
class Zip::File < ::Zip::CentralDirectory
  # source://rubyzip//lib/zip/file.rb#76
  def initialize(path_or_io, create = T.unsafe(nil), buffer = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/file.rb#299
  def add(entry, src_path, &continue_on_exists_proc); end

  # source://rubyzip//lib/zip/file.rb#310
  def add_stored(entry, src_path, &continue_on_exists_proc); end

  # source://rubyzip//lib/zip/file.rb#372
  def close; end

  # source://rubyzip//lib/zip/file.rb#72
  def comment; end

  # source://rubyzip//lib/zip/file.rb#72
  def comment=(_arg0); end

  # source://rubyzip//lib/zip/file.rb#346
  def commit; end

  # source://rubyzip//lib/zip/file.rb#378
  def commit_required?; end

  # source://rubyzip//lib/zip/file.rb#338
  def extract(entry, dest_path, &block); end

  # source://rubyzip//lib/zip/file.rb#387
  def find_entry(entry_name); end

  # source://rubyzip//lib/zip/file.rb#404
  def get_entry(entry); end

  # source://rubyzip//lib/zip/file.rb#258
  def get_input_stream(entry, &a_proc); end

  # source://rubyzip//lib/zip/file.rb#267
  def get_output_stream(entry, permission_int = T.unsafe(nil), comment = T.unsafe(nil), extra = T.unsafe(nil), compressed_size = T.unsafe(nil), crc = T.unsafe(nil), compression_method = T.unsafe(nil), size = T.unsafe(nil), time = T.unsafe(nil), &a_proc); end

  # source://rubyzip//lib/zip/file.rb#398
  def glob(*args, &block); end

  # source://rubyzip//lib/zip/file.rb#412
  def mkdir(entry_name, permission = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/file.rb#60
  def name; end

  # source://rubyzip//lib/zip/file.rb#294
  def read(entry); end

  # source://rubyzip//lib/zip/file.rb#316
  def remove(entry); end

  # source://rubyzip//lib/zip/file.rb#321
  def rename(entry, new_name, &continue_on_exists_proc); end

  # source://rubyzip//lib/zip/file.rb#331
  def replace(entry, src_path); end

  # source://rubyzip//lib/zip/file.rb#63
  def restore_ownership; end

  # source://rubyzip//lib/zip/file.rb#63
  def restore_ownership=(_arg0); end

  # source://rubyzip//lib/zip/file.rb#66
  def restore_permissions; end

  # source://rubyzip//lib/zip/file.rb#66
  def restore_permissions=(_arg0); end

  # source://rubyzip//lib/zip/file.rb#69
  def restore_times; end

  # source://rubyzip//lib/zip/file.rb#69
  def restore_times=(_arg0); end

  # source://rubyzip//lib/zip/file.rb#289
  def to_s; end

  # source://rubyzip//lib/zip/file.rb#364
  def write_buffer(io = T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/file.rb#434
  def check_entry_exists(entry_name, continue_on_exists_proc, proc_name); end

  # source://rubyzip//lib/zip/file.rb#446
  def check_file(path); end

  # source://rubyzip//lib/zip/file.rb#422
  def directory?(new_entry, src_path); end

  # source://rubyzip//lib/zip/file.rb#450
  def on_success_replace; end

  class << self
    # source://rubyzip//lib/zip/file.rb#132
    def add_buffer; end

    # source://rubyzip//lib/zip/file.rb#171
    def foreach(zip_file_name, &block); end

    # source://rubyzip//lib/zip/file.rb#187
    def get_partial_zip_file_name(zip_file_name, partial_zip_file_name); end

    # source://rubyzip//lib/zip/file.rb#196
    def get_segment_count_for_split(zip_file_size, segment_size); end

    # source://rubyzip//lib/zip/file.rb#177
    def get_segment_size_for_split(segment_size); end

    # source://rubyzip//lib/zip/file.rb#120
    def open(file_name, create = T.unsafe(nil), options = T.unsafe(nil)); end

    # source://rubyzip//lib/zip/file.rb#143
    def open_buffer(io, options = T.unsafe(nil)); end

    # source://rubyzip//lib/zip/file.rb#200
    def put_split_signature(szip_file, segment_size); end

    # source://rubyzip//lib/zip/file.rb#209
    def save_splited_part(zip_file, partial_zip_file_name, zip_file_size, szip_file_index, segment_size, segment_count); end

    # source://rubyzip//lib/zip/file.rb#231
    def split(zip_file_name, segment_size = T.unsafe(nil), delete_zip_file = T.unsafe(nil), partial_zip_file_name = T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/file.rb#46
Zip::File::CREATE = T.let(T.unsafe(nil), TrueClass)

# source://rubyzip//lib/zip/file.rb#51
Zip::File::DATA_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#54
Zip::File::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/file.rb#52
Zip::File::IO_METHODS = T.let(T.unsafe(nil), Array)

# source://rubyzip//lib/zip/file.rb#49
Zip::File::MAX_SEGMENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#50
Zip::File::MIN_SEGMENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#47
Zip::File::SPLIT_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#48
Zip::File::ZIP64_EOCD_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#9
class Zip::GPFBit3Error < ::Zip::Error; end

# source://rubyzip//lib/zip/ioextras.rb#2
module Zip::IOExtras
  class << self
    # source://rubyzip//lib/zip/ioextras.rb#8
    def copy_stream(ostream, istream); end

    # source://rubyzip//lib/zip/ioextras.rb#12
    def copy_stream_n(ostream, istream, nbytes); end
  end
end

# source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#6
module Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#10
  def initialize; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#107
  def each(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#107
  def each_line(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#115
  def eof; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#115
  def eof?; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#94
  def flush; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#58
  def gets(a_sep_string = T.unsafe(nil), number_of_bytes = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#17
  def lineno; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#17
  def lineno=(_arg0); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#18
  def pos; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#20
  def read(number_of_bytes = T.unsafe(nil), buf = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#100
  def readline(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#52
  def readlines(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#90
  def ungetc(byte); end
end

# source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#5
module Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#13
  def print(*params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#17
  def printf(a_format_string, *params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#21
  def putc(an_object); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#33
  def puts(*params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#8
  def write(data); end
end

# source://rubyzip//lib/zip/ioextras.rb#3
Zip::IOExtras::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/ioextras.rb#23
module Zip::IOExtras::FakeIO
  # source://rubyzip//lib/zip/ioextras.rb#24
  def kind_of?(object); end
end

# source://rubyzip//lib/zip/ioextras.rb#5
Zip::IOExtras::RANGE_ALL = T.let(T.unsafe(nil), Range)

# source://rubyzip//lib/zip/inflater.rb#2
class Zip::Inflater < ::Zip::Decompressor
  # source://rubyzip//lib/zip/inflater.rb#3
  def initialize(*args); end

  # source://rubyzip//lib/zip/inflater.rb#22
  def eof; end

  # source://rubyzip//lib/zip/inflater.rb#22
  def eof?; end

  # source://rubyzip//lib/zip/inflater.rb#10
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/inflater.rb#44
  def input_finished?; end

  # source://rubyzip//lib/zip/inflater.rb#30
  def produce_input; end
end

# source://rubyzip//lib/zip/input_stream.rb#41
class Zip::InputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractInputStream

  # source://rubyzip//lib/zip/input_stream.rb#52
  def initialize(context, offset = T.unsafe(nil), decrypter = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/input_stream.rb#60
  def close; end

  # source://rubyzip//lib/zip/input_stream.rb#68
  def get_next_entry; end

  # source://rubyzip//lib/zip/input_stream.rb#74
  def rewind; end

  # source://rubyzip//lib/zip/input_stream.rb#84
  def sysread(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  protected

  # source://rubyzip//lib/zip/input_stream.rb#149
  def get_decompressor; end

  # source://rubyzip//lib/zip/input_stream.rb#142
  def get_decrypted_io; end

  # source://rubyzip//lib/zip/input_stream.rb#111
  def get_io(io_or_file, offset = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/input_stream.rb#172
  def input_finished?; end

  # source://rubyzip//lib/zip/input_stream.rb#123
  def open_entry; end

  # source://rubyzip//lib/zip/input_stream.rb#168
  def produce_input; end

  class << self
    # source://rubyzip//lib/zip/input_stream.rb#92
    def open(filename_or_io, offset = T.unsafe(nil), decrypter = T.unsafe(nil)); end

    # source://rubyzip//lib/zip/input_stream.rb#103
    def open_buffer(filename_or_io, offset = T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/input_stream.rb#42
Zip::InputStream::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#8
class Zip::InternalError < ::Zip::Error; end

# source://rubyzip//lib/zip/constants.rb#7
Zip::LOCAL_ENTRY_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#8
Zip::LOCAL_ENTRY_STATIC_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#9
Zip::LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/null_compressor.rb#2
class Zip::NullCompressor < ::Zip::Compressor
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # source://rubyzip//lib/zip/null_compressor.rb#5
  def <<(_data); end

  # source://rubyzip//lib/zip/null_compressor.rb#9
  def compressed_size; end

  # source://rubyzip//lib/zip/null_compressor.rb#9
  def size; end
end

# source://rubyzip//lib/zip/null_decompressor.rb#2
module Zip::NullDecompressor
  private

  # source://rubyzip//lib/zip/null_decompressor.rb#9
  def eof; end

  # source://rubyzip//lib/zip/null_decompressor.rb#9
  def eof?; end

  # source://rubyzip//lib/zip/null_decompressor.rb#5
  def read(_length = T.unsafe(nil), _outbuf = T.unsafe(nil)); end

  class << self
    # source://rubyzip//lib/zip/null_decompressor.rb#9
    def eof; end

    # source://rubyzip//lib/zip/null_decompressor.rb#5
    def read(_length = T.unsafe(nil), _outbuf = T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/crypto/null_encryption.rb#30
class Zip::NullDecrypter < ::Zip::Decrypter
  include ::Zip::NullEncryption

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#33
  def decrypt(data); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#37
  def reset!(_header); end
end

# source://rubyzip//lib/zip/crypto/null_encryption.rb#12
class Zip::NullEncrypter < ::Zip::Encrypter
  include ::Zip::NullEncryption

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#23
  def data_descriptor(_crc32, _compressed_size, _uncomprssed_size); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#19
  def encrypt(data); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#15
  def header(_mtime); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#27
  def reset!; end
end

# source://rubyzip//lib/zip/crypto/null_encryption.rb#2
module Zip::NullEncryption
  # source://rubyzip//lib/zip/crypto/null_encryption.rb#7
  def gp_flags; end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#3
  def header_bytesize; end
end

# source://rubyzip//lib/zip/null_input_stream.rb#2
module Zip::NullInputStream
  include ::Zip::NullDecompressor
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractInputStream
end

# source://rubyzip//lib/zip/output_stream.rb#20
class Zip::OutputStream
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractOutputStream

  # source://rubyzip//lib/zip/output_stream.rb#27
  def initialize(file_name, stream = T.unsafe(nil), encrypter = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/output_stream.rb#189
  def <<(data); end

  # source://rubyzip//lib/zip/output_stream.rb#69
  def close; end

  # source://rubyzip//lib/zip/output_stream.rb#80
  def close_buffer; end

  # source://rubyzip//lib/zip/output_stream.rb#23
  def comment; end

  # source://rubyzip//lib/zip/output_stream.rb#23
  def comment=(_arg0); end

  # source://rubyzip//lib/zip/output_stream.rb#109
  def copy_raw_entry(entry); end

  # source://rubyzip//lib/zip/output_stream.rb#92
  def put_next_entry(entry_name, comment = T.unsafe(nil), extra = T.unsafe(nil), compression_method = T.unsafe(nil), level = T.unsafe(nil)); end

  protected

  # source://rubyzip//lib/zip/output_stream.rb#182
  def finish; end

  private

  # source://rubyzip//lib/zip/output_stream.rb#130
  def finalize_current_entry; end

  # source://rubyzip//lib/zip/output_stream.rb#154
  def get_compressor(entry, level); end

  # source://rubyzip//lib/zip/output_stream.rb#145
  def init_next_entry(entry, level = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/output_stream.rb#166
  def update_local_headers; end

  # source://rubyzip//lib/zip/output_stream.rb#175
  def write_central_directory; end

  class << self
    # source://rubyzip//lib/zip/output_stream.rb#50
    def open(file_name, encrypter = T.unsafe(nil)); end

    # source://rubyzip//lib/zip/output_stream.rb#60
    def write_buffer(io = T.unsafe(nil), encrypter = T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/pass_thru_compressor.rb#2
class Zip::PassThruCompressor < ::Zip::Compressor
  # source://rubyzip//lib/zip/pass_thru_compressor.rb#3
  def initialize(output_stream); end

  # source://rubyzip//lib/zip/pass_thru_compressor.rb#10
  def <<(data); end

  # source://rubyzip//lib/zip/pass_thru_compressor.rb#17
  def crc; end

  # source://rubyzip//lib/zip/pass_thru_compressor.rb#17
  def size; end
end

# source://rubyzip//lib/zip/pass_thru_decompressor.rb#2
class Zip::PassThruDecompressor < ::Zip::Decompressor
  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#3
  def initialize(*args); end

  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#19
  def eof; end

  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#19
  def eof?; end

  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#8
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end
end

# source://rubyzip//lib/zip/constants.rb#2
Zip::RUNNING_ON_WINDOWS = T.let(T.unsafe(nil), T.untyped)

# source://rubyzip//lib/zip/streamable_directory.rb#2
class Zip::StreamableDirectory < ::Zip::Entry
  # source://rubyzip//lib/zip/streamable_directory.rb#3
  def initialize(zipfile, entry, src_path = T.unsafe(nil), permission = T.unsafe(nil)); end
end

# source://rubyzip//lib/zip/streamable_stream.rb#2
class Zip::StreamableStream
  # source://rubyzip//lib/zip/streamable_stream.rb#3
  def initialize(entry); end

  # source://rubyzip//lib/zip/streamable_stream.rb#44
  def clean_up; end

  # source://rubyzip//lib/zip/streamable_stream.rb#21
  def get_input_stream; end

  # source://rubyzip//lib/zip/streamable_stream.rb#9
  def get_output_stream; end

  # source://rubyzip//lib/zip/streamable_stream.rb#39
  def write_to_zip_output_stream(output_stream); end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#73
class Zip::TraditionalDecrypter < ::Zip::Decrypter
  include ::Zip::TraditionalEncryption

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#76
  def decrypt(data); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#80
  def reset!(header); end

  private

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#89
  def decode(num); end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#39
class Zip::TraditionalEncrypter < ::Zip::Encrypter
  include ::Zip::TraditionalEncryption

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#56
  def data_descriptor(crc32, compressed_size, uncomprssed_size); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#52
  def encrypt(data); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#42
  def header(mtime); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#60
  def reset!; end

  private

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#66
  def encode(num); end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#2
module Zip::TraditionalEncryption
  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#3
  def initialize(password); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#12
  def gp_flags; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#8
  def header_bytesize; end

  protected

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#33
  def decrypt_byte; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#18
  def reset_keys!; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#27
  def update_keys(num); end
end

# source://rubyzip//lib/zip/constants.rb#10
Zip::VERSION_MADE_BY = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#11
Zip::VERSION_NEEDED_TO_EXTRACT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#12
Zip::VERSION_NEEDED_TO_EXTRACT_ZIP64 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#16
Zip::ZipCompressionMethodError = Zip::CompressionMethodError

# source://rubyzip//lib/zip/errors.rb#15
Zip::ZipDestinationFileExistsError = Zip::DestinationFileExistsError

# source://rubyzip//lib/zip/errors.rb#14
Zip::ZipEntryExistsError = Zip::EntryExistsError

# source://rubyzip//lib/zip/errors.rb#17
Zip::ZipEntryNameError = Zip::EntryNameError

# source://rubyzip//lib/zip/errors.rb#13
Zip::ZipError = Zip::Error

# source://rubyzip//lib/zip/errors.rb#18
Zip::ZipInternalError = Zip::InternalError
